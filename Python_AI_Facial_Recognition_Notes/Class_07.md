# 第七讲：“可恨”的Bug

---

**目录：**

[TOC]

---

## 一、Python程序的执行顺序

从整体上讲：
* Python程序的执行顺序是**从上到下、从前到后**依次执行的.

从局部上讲：
* 如果遇到数据定义和初始化：
  * 执行数据定义和初始化的行代码.
* 如果遇到函数定义和声明：
  * 只执行函数的定义和声明（即`def ...`）的行代码；
  * 不执行具体的函数体.
* 如果遇到函数调用：
  * 进入相应的函数体中执行相应的代码；
  * 执行完成之后从子程序中返回中断处继续执行下一行代码.

---

## 二、实操案例——猜拳游戏

> 实现一个猜拳游戏的实操案例，该案例需求为：
> 
> * 游戏规则：
>   * 用户可以自主选择是否进入游戏；
>   * 在每一轮游戏结束之后，用户可以自主选择是否继续游戏；
>   * 在每一轮游戏中，由用户给出的“石头”、“剪刀”、“布”中的任意一种选择与电脑随机给出的一种选择进行比较，并根据猜拳游戏的胜负规则输出：
>       * 用户的选择；
>       * 电脑的选择；
>       * 比赛的最终胜负情况.
> 
> * 程序质量应满足：
>   * 正确性；
>   * 健壮性.

``` Python
    import random

    lst = ['石头', '剪刀', '布']


    def start_window():
        print("***************************")
        print("--------1. 进入游戏---------")
        print("--------0. 退出游戏---------")
        print("***************************")


    def start_game():
        print("*************************")
        print("--------1.石   头--------")
        print("--------2.剪   刀--------")
        print("--------3.     布--------")
        print("--------0.退出游戏--------")
        print("*************************")


    def print_result(m, n, result):
        """
        打印游戏的结果.
        :param m: 用户输入的.
        :param n: 电脑随机生成的.
        :param result: 结果字符串.
        :return:
        """
        my_choice = lst[m - 1]  # 将输入的数字转换成文字（1.石头 2.剪刀 3.布）
        com_choice = lst[n - 1] # 将输入的数字转换成文字（1.石头 2.剪刀 3.布）
        print(f"你的选择是：{my_choice}.")
        print(f"对方（电脑）的选择是：{com_choice}.")
        print(result)


    print("欢迎来到我的猜拳游戏！")
    while True:
        start_window()  # 进入欢迎界面.
        i = int(input("请输入你的选择："))  # 进入游戏或者退出游戏.
        if i == 1:  # 用户开始游戏.
            start_game()
            """
            
            """
            m = int(input("请输入你的选择："))
            if m == 0:
                break;  # 退出游戏界面.
            if m < 1 or m > 3:
                print("输入的数值不合法！")
                print("再见！")
                break
            # 电脑随机生成随机数：
            n = random.randint(1, 3)  # 闭合的区间范围.
            if m == n:
                print_result(m, n, "平局！")
            elif m - n == 1 or m - n == -2:
                print_result(m, n, "对不起，你输了！")
            else:
                print_result(m, n, "恭喜你，你赢了！")
        elif i == 0:
            print("退出游戏！")
            print("再见！")
            break
        else:
            print("输入的数值不合法！")
            print("再见！")
            break
```

> 注意：
> * 字符串和整型数据可以使用 `==` 进行比较.
> * 字符串和整型数据不能使用 `>`、`<`、`>=`、`<=` 进行比较.
>   * 会报错！

---

## 三、DeBug常用技巧

DeBug常用技巧分为两类：

* 通过**debug调试工具**进行调试：
  * 适用场景：
    * 复杂的Bug类型；
    * 根据错误描述信息无法精确找到错误所在处.
  * 核心要点：
    * ==断点的设置位置==.
* 根据**错误的描述信息**来解决Bug：
  * 适用场景：
    * 简单的Bug类型；
    * 如果通过debug调试工具进行调试，将会非常繁琐.
  * 核心要点：
    * ==能够通过报错信息找到出现错误的代码行的位置==.

> 通常来说，通过debug调试工具进行DeBug调试要比根据错误的描述信息来解决bug更加繁琐和耗时.

### 3.1 通过debug调试工具进行调试

**适用场景：** 较为复杂的Bug类型.

**核心要点：** ==断点的设置位置==.

* 断点一般设置在顺序执行的、可能出现错误的代码的前面.
* 断点一般不直接设置在程序的入口处.
  * 程序的入口处通常是数据的定义和声明，以及通过`print()函数`进行项目描述的代码.
    * 一般不会出现错误.

**debug调试工具中重要的调试方法：**

* `step over`（`F8`）：
  * 功能：
    * 单步执行.
* `step into`（`F7`）：
  * 功能：
    * 在单步执行遇到子函数时，可以通过`step into`进入子函数中并通过`step over`继续单步执行.
* `step out`（`Shift + F8`）：
  * 功能：
    * 从函数体中跳出.
* `resume program`（`F9`）：
  * 功能：
    * 继续恢复程序，直接运行到下一断点处.

> 常见的英文释义：
> * `console`：
>   * 控制台.
> * `exception`：
>   * 程序异常.

### 3.2 根据错误的描述信息来解决Bug

**适用场景：** 较为简单的Bug类型.

**核心要点：** ==能够通过报错信息找到出现错误的代码行的位置==.

**调试步骤：**

1. 看错误描述信息：
    * 错误描述信息：
      * 红色的大段英文文字.
    * 不管报什么样的错误，只需要看报错信息的最后一行：
      * 最后一行会显示错误类型：`X×××××Error`.
        * `TypeError`：`类型错误`.
2. 从最后一行报错往上找：
    * 找到第一个出现错误的代码位置是你自己写的`.py代码`的源代码的位置.
      * 可能会有一些Python本身的`.py文件`也会出现在报错信息中.
      * 因此这里必须是你自己写的`.py代码`的源代码的位置.

> 注意：
> 在根据错误的描述信息来解决Bug时：
> * 不需要加断点和使用debug调试工具；
> * 直接让代码跑起来，观察最终输出的错误描述信息.

---

## 四、课堂小结

代码能力评判的重要指标：

* 解决问题的能力.
* ==DeBug的能力==.